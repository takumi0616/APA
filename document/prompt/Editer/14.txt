# タスク（プロンプト）を行う前に必ず以下の資料を読んでください

この資料は環境がどう構築されたかを記しておりコマンド実行などの際は必ず参考にしてください
@/git_installation_guide.md
@/miniconda_installation_guide.md

タスクを行った際は、タスク成功後に、行ったことをマークダウン記法でまとめたものを@/APA\document\report の中にファイルを作成してください
ファイル名のルール：番号_年月日_行ったことを日本語.md（例：1_20260106_環境構築）
番号は@/APA\document\report の中を精査して確認してください
これまでのreportも読み込んでからタスクを行ってください
---
# プロンプト

@/APA\paper_pipeline_v7.py 
上記のプログラムに以下の改善を行ってほしいです

改善1
```
現在以下のフォーム判断アルゴリズムがあります
4) フォーム判定（回転探索）
   - 角度リストは仕様として `0..350` を `--rotation-step` 刻みで作成
   - 実処理は高速化のため Coarse-to-Fine
     - coarse: 0/45/90/.../315 の 8 方向で粗探索し、上位2角度を選ぶ
       - この coarse 段階で QR が 1 度も見つからなければ「フォームBではない」と判断し、以降フォームBの探索は行わない
     - fine  : 上位角度の近傍（±50度）だけ、上記の角度リスト内で細かく探索
     - fine で何も見つからない場合は Unknown（no_detection）とする（救済処置は行わない）
   - フォームA: 3点マーク（TL/TR/BL）が検出できる（`--marker-preproc` で前処理オプション）
   - フォームB: QRコードが検出できる
     - まず高速（軽量）検出で角度候補を絞り、最後に robust 検出で確定
     - `--wechat-model-dir` にモデルがあり、opencv-contrib が入っていれば WeChat QR エンジンを優先（小さいQRに強い）
   - 判定不能/曖昧なら `stage=form_unknown`（Unknown）で終了

この中のフォームAとフォームBにおいて、角度を変えた検出および位置合わせのスコアの計算などを行っています
フォームA、BにおいてCoarse-to-Fineを採用していますが、これを変更したいです
fineの16方向のみにして欲しいです
そして最上位角度を用いて判定と角度確定を行って欲しいです
```

改善2
```
A-1) WeChat QR のマルチスケールを見直す（かなり効く可能性）
現状 detect_qr_codes_wechat_multiscale(mode="fast") で、画像が大きい場合でも [1.0, 0.75, 0.5] を試しており、1角度で最大3回 WeChat を呼ぶ構造です。

ただし、WeChat QR は内部で入力を縮小してからNNを回す（デフォルトは面積160000px相当）ので(docs.opencv.org)、**「大きい画像に対する 0.75 / 0.5 の試行は“ほぼ同じネット入力サイズ”になりやすく、効果が薄いわりにコストだけ増える」**可能性が高いです。

具体的にやること（提案）
fast モードでは「縮小スケール（<1）」をやめて [1.0] の1発にする
“小さい画像のときだけ” up-scale を試す（今の思想はそのまま）
例（方針だけ）：

# mode=="fast" のとき
scales = [1.0]
if max(h0, w0) < up_scale_enable_max_side_px:
    scales += [1.25, 1.5]
これで B の decide が数倍速くなる余地があります（角度×スケールの掛け算が減るので）。


```

上記の改善を順番に確実に行ってください
プログラムをすべて改善できたのちに実行して結果確認、エラーが出る場合は試行錯誤して適宜改善してください
全ての改善が無事に終了したときに、レポートの作成を行ってください
